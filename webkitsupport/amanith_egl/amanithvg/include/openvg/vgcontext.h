/****************************************************************************
** Copyright (C) 2004-2009 Mazatech S.r.l. All rights reserved.
**
** This file is part of AmanithVG software, an OpenVG implementation.
** This file is strictly confidential under the signed Mazatech Software
** Non-disclosure agreement and it's provided according to the signed
** Mazatech Software licensing agreement.
**
** Khronos and OpenVG are trademarks of The Khronos Group Inc.
** OpenGL is a registered trademark and OpenGL ES is a trademark of
** Silicon Graphics, Inc.
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
** For any information, please contact info@mazatech.com
**
****************************************************************************/

#ifndef _VGCONTEXT_H
#define _VGCONTEXT_H

/*!
	\file vgcontext.h
	\brief OpenVG context, header.
	\author Matteo Muratori
	\author Michele Fabbri
*/

#include "rasterizer.h"
#include "vgscissors.h"
#include "vgfilters.h"
#include "vgpath.h"
#include "vgpaint.h"
#include "vgimage.h"

#if defined(AM_GLE) || defined(AM_GLS)
// forceBufferDisabled option (external config file)
#define AM_NO_BUFFER_DISABLED				0
#define AM_STENCIL_BUFFER_DISABLED			1
#define AM_DEPTH_BUFFER_DISABLED			2
#endif

#if defined(VG_MZT_statistics)
//! Structure used to store statistics (performance) information.
typedef struct _AMStatisticsInfo {
	//! Number of points generated by flattening routines.
	AMuint32 flatteningPointsCount;
	//! Milliseconds spent to generate the flattening.
	AMuint32 flatteningTimeMS;
	//! Number of times that amPathFlatten really perform flattening.
	AMuint32 flatteningPerformedCount;
	//! Milliseconds spent to perform polygon rasterization (clipping + matrix transformation + rasterizer + fillers).
	AMuint32 rasterizerTotalTimeMS;
	//! Number of triangles generated by triangulator.
	AMuint32 triangulationTrianglesCount;
	//! Milliseconds spent to generate the triangulations.
	AMuint32 triangulationTimeMS;
	//! Number of points generated by stroking routines.
	AMuint32 strokerPointsCount;
	//! Milliseconds spent to generate the stroke.
	AMuint32 strokerTimeMS;
	//! Number of performed glDrawElements calls.
	AMuint32 glDrawElementsCount;
	//! Number of performed glDrawArrays calls.
	AMuint32 glDrawArraysCount;
} AMStatisticsInfo;
#endif

//! Structure used to store AmanithVG configuration parameters (read from the external configuration file).
typedef struct _AMContextConfParams {
	//! A value between 0.01 and 1.5; 0.01 represents the best curve approximation quality.
	AMfloat curvesQuality;
#if defined(AM_GLE) || defined(AM_GLS)
	//! AM_TRUE to force rectangular texture off, else AM_FALSE.
	AMbool forceRectTexturesDisabled;
	//! AM_TRUE to force mirrored repeat wrap mode off, else AM_FALSE.
	AMbool forceMirroredRepeatDisabled;
	//! AM_TRUE to force border clamping off, else AM_FALSE.
	AMbool forceClampToBorderDisabled;
	//! AM_TRUE to force min/max blend equation off, else AM_FALSE.
	AMbool forceBlendMinMaxDisabled;
	//! AM_TRUE to force dot3 combiner operation off, else AM_FALSE.
	AMbool forceDot3Disabled;
	//! AM_TRUE to force Vertex Buffer Objects (VBO) off, else AM_FALSE.
	AMbool forceVBODisabled;
	//! Number of texture units that AmanithVG is allowed to use.
	AMint32 maxPermittedTextureUnits;
	//! Maximum texture dimension that AmanithVG is allowed to use.
	AMint32 maxTextureSize;
	/*!
		One of the following values: AM_NO_BUFFER_DISABLED, AM_STENCIL_BUFFER_DISABLED, AM_DEPTH_BUFFER_DISABLED.
		Used to force AmanithVG to not use depth or stencil buffer.
	*/
	AMuint32 forceBufferDisabled;
	//! AM_TRUE if it's supposed that GL buffer's content remains consistent after a "swap buffers" operation, else AM_FALSE.
	AMbool supposePersistentBuffer;
	//! AM_TRUE to force scissor feature off, else AM_FALSE.
	AMbool forceScissorDisabled;
	//! AM_TRUE to force color masking feature off, else AM_FALSE.
	AMbool forceColorMaskingDisabled;
	//! AM_TRUE to force mipmaps generation on gradient textures, else AM_FALSE.
	AMbool forceMimMapsOnGradients;
	//! AM_TRUE to force dithering on gradient textures when pixels are uploaded, else AM_FALSE.
	AMbool forceDitheringOnGradients;
	//! AM_TRUE to force dithering on image textures when pixels are uploaded, else AM_FALSE.
	AMbool forceDitheringOnImages;
	//! If AM_TRUE it forces GL_RGBA texture format even for opaque paint/images. If AM_FALSE use GL_RGB texture format for opaque paint/images.
	AMbool forceRGBATextures;
#endif
#if defined(AM_GLE)
	//! A value between 0.01 and 1.5; 0.01 represents the best radial gradient quality.
	AMfloat radialGradientsQuality;
	//! A value between 0.01 and 1.5; 0.01 represents the best conical gradient quality.
	AMfloat conicalGradientsQuality;
#endif
} AMContextConfParams;

//! Structure used to store context handle list.
typedef struct _AMContextHandlesList {
	//! List of created VGHandle(s): VGPaint, VGPath, VGImage, VGMaskLayer, VGFont.
	AMHandleDynArray createdHandlesList;
	//! Memory management, a counter used to manage the memory allocated for the list of created handles.
	AMuint32 memMngCreatedHandles;
	//! List of available VGHandle(s), to be reused.
	AMUint32DynArray availableHandlesList;
	//! Memory management, a counter used to sort the list of available handles.
	AMuint32 memMngAvailableHandles;
	//! Pools of AMPath(s).
	AMPathsPoolsManager pathsPools;
	//! Pools of AMPaint(s).
	AMPaintsPoolsManager paintsPools;
	//! Reference counter.
	AMuint32 referenceCounter;
} AMContextHandlesList;

//! OpenVG context structure.
typedef struct _AMContext {
	//!	\name Original (unpatched) OpenVG values.
	//@{
	//! Matrix mode.
	VGMatrixMode matrixMode;
	//! Fill rule.
	VGFillRule fillRule;
	//! Image quality.
	VGImageQuality imageQuality;
	//! Rendering quality.
	VGRenderingQuality renderingQuality;
	//! Blend mode (stroke).
	VGBlendMode strokeBlendMode;
	//! Blend mode (fill).
	VGBlendMode fillBlendMode;
	//! Image mode.
	VGImageMode imageMode;
	//! Scissor rectangles.
	AMInt32DynArray scissorRects;
#if (AM_OPENVG_VERSION >= 110)
    //! Color transformation.
	VGboolean colorTransform;
	//! Color transformation values.
	VGfloat colorTransformValues[8];
#endif
	//! Stroke line width.
	VGfloat strokeLineWidth;
	//! Cap style (start caps).
	VGCapStyle startCapStyle;
	//! Cap style (end caps).
	VGCapStyle endCapStyle;
	//! Join style.
	VGJoinStyle joinStyle;
	//! Miter limit.
	VGfloat miterLimit;
	//! Dash pattern.
	AMFloatDynArray dashPattern;
	//! Dash phase.
	VGfloat dashPhase;
	//! Dash phase reset flag.
	VGboolean dashPhaseReset;
	//! Tile fill color for VG_TILE_FILL tiling mode, in non-linear non-premultiplied format.
	VGfloat tileFillColor[4];
	//! Clear color, in non-linear non-premultiplied format.
	VGfloat clearColor[4];
#if (AM_OPENVG_VERSION >= 110)
	//! Glyph origin.
	VGfloat glyphOrigin[2];
#endif
	//! Masking flag (enabled/disabled).
	VGboolean masking;
	//! Scissoring flag (enabled/disabled).
	VGboolean scissoring;
	//! Pixel layout hint information.
	VGPixelLayout pixelLayout;
	//! Screen layout (read-only).
	VGPixelLayout screenLayout;
	//! Color space where to apply image filters is linear.
	VGboolean filterFormatLinear;
	//! Color space where to apply image filters is premultiplied.
	VGboolean filterFormatPremultiplied;
	//! Destination write enable mask for image filters.
	VGbitfield filterChannelMask;
	//! Maximum supported scissor rectangles (read-only).
	VGint maxScissorRects;
	//! Maximum supported dash pattern values (read-only).
	VGint maxDashCount;
	//! Maximum supported kernel size (read-only).
	VGint maxKernelSize;
	//! Maximum supported separable kernel size (read-only).
	VGint maxSeparableKernelSize;
	//! Maximum supported number of color stops (read-only).
	VGint maxColorRampStops;
	//! Maximum supported image width, in pixels (read-only).
	VGint maxImageWidth;
	//! Maximum supported image height, in pixels (read-only).
	VGint maxImageHeight;
	//! Maximum supported image pixel number (read-only).
	VGint maxImagePixels;
	//! Maximum supported image memory to store pixels, in bytes (read-only).
	VGint maxImageBytes;
	//! Largest floating point number accepted by AmanithVG (read-only).
	VGfloat maxFloat;
	//! Maximum supported standard deviation by the Gaussian filter (read-only).
	VGint maxGaussianStdDeviation;
	//! Current OpenVG error code (read-only).
	VGErrorCode error;
	//! Current VG_MATRIX_PATH_USER_TO_SURFACE matrix.
	AMMatrix33f pathUserToSurface;
	//! Current VG_MATRIX_IMAGE_USER_TO_SURFACE matrix.
	AMMatrix33f imageUserToSurface;
	//! Current VG_MATRIX_FILL_PAINT_TO_USER matrix.
	AMMatrix33f fillPaintToUser;
	//! Current VG_MATRIX_STROKE_PAINT_TO_USER matrix.
	AMMatrix33f strokePaintToUser;
#if (AM_OPENVG_VERSION >= 110)
	//! Current VG_MATRIX_GLYPH_USER_TO_SURFACE matrix.
	AMMatrix33f glyphUserToSurface;
#endif
	//! Current stroke paint handle.
	VGHandle strokePaint;
	//! Current fill paint handle.
	VGHandle fillPaint;
	//@}

#if defined(AM_GLE) || defined(AM_GLS)
	//! OpenGL / OpenGL ES context.
	AMGLContext glContext;
	//! Triangulator.
	AMTriangulator *triangulator;
#endif

	//! List of created VGHandle(s): VGPaint, VGPath, VGImage, VGMaskLayer, VGFont.
	AMContextHandlesList *handles;
	//! Pointer to a shared context (can be NULL too).
	struct _AMContext *sharedContext;

	//!	\name Auxiliary structures used to decompose OpenVG scissor rectangles into a set of non-overlapping rectangles.
	//@{
	//! AM_TRUE when scissor rectangles have been modified.
	AMbool scissorRectsModified;
#if defined(AM_GLE) || defined(AM_GLS)
	AMbool scissorRectsNeedUpload;
	//! The scissoring state (VG_TRUE / VG_FALSE) relative to the latest draw call.
	VGboolean scissoringLastDraw;
#endif
	//! Non-overlapping scissor rectangles.
	AMScissorRectDynArray splitScissorRects;
	//! Bounding box of non overlapping scissor rectangles.
	AMAABox2i splitScissorRectsBox;
	//@}

#if (AM_OPENVG_VERSION >= 110)
	//! Clamped color transformation values (scale parameters are clamped to the range [-127.0, +127.0], bias parameters are clamped to the range [-1.0, +1.0]).
	AMfloat clampedColorTransformValues[8];
	//! Hash value generated from clamped color transformation values. NB: this hash includes the colorTransform flag (enabled/disabled) too.
	AMuint32 colorTransformHash;
	//! AM_TRUE if all bias are 0.0f and scale factors are <= 1.0f
	AMbool ctNormalizedValues;
#endif

#if !defined(AM_LITE_PROFILE)
	//!	\name Image filters related structures.
	//@{
	//! Horizontal separable kernel used by Gaussian filter; it has a fixed size of (6 * maxGaussianStdDeviation + 1).
	AMint16 *gaussianKernelX;
	//! Vertical separable kernel used by Gaussian filter; it has a fixed size of (6 * maxGaussianStdDeviation + 1).
	AMint16 *gaussianKernelY;
	//@}
#endif

	//!	\name Matrices related values and status.
	//@{
	//! Inverse of the current VG_MATRIX_PATH_USER_TO_SURFACE matrix.
	AMMatrix33f inversePathUserToSurface;
	//! Scale factors extracted from the current VG_MATRIX_PATH_USER_TO_SURFACE matrix.
	AMfloat pathUserToSurfaceScale[2];
	//! Flags to describe the status of the current VG_MATRIX_PATH_USER_TO_SURFACE matrix.
	AMuint32 pathUserToSurfaceFlags;
	//! Inverse of the current VG_MATRIX_IMAGE_USER_TO_SURFACE matrix.
	AMMatrix33f inverseImageUserToSurface;
	//! Scale factors extracted from the current VG_MATRIX_IMAGE_USER_TO_SURFACE matrix.
	AMfloat imageUserToSurfaceScale[2];
	//! Flags to describe the status of the current VG_MATRIX_IMAGE_USER_TO_SURFACE matrix.
	AMuint32 imageUserToSurfaceFlags;
	//! Inverse of the current VG_MATRIX_FILL_PAINT_TO_USER matrix.
	AMMatrix33f inverseFillPaintToUser;
	//! Scale factors extracted from the current VG_MATRIX_FILL_PAINT_TO_USER matrix.
	AMfloat fillPaintToUserScale[2];
	//! Flags to describe the status of the current VG_MATRIX_FILL_PAINT_TO_USER matrix.
	AMuint32 fillPaintToUserFlags;
	//! Inverse of the current VG_MATRIX_STROKE_PAINT_TO_USER matrix.
	AMMatrix33f inverseStrokePaintToUser;
	//! Scale factors extracted from the current VG_MATRIX_STROKE_PAINT_TO_USER matrix.
	AMfloat strokePaintToUserScale[2];
	//! Flags to describe the status of the current VG_MATRIX_STROKE_PAINT_TO_USER matrix.
	AMuint32 strokePaintToUserFlags;
#if (AM_OPENVG_VERSION >= 110)
	//! Inverse of the current VG_MATRIX_GLYPH_USER_TO_SURFACE matrix.
	AMMatrix33f inverseGlyphUserToSurface;
	//! Scale factors extracted from the current VG_MATRIX_GLYPH_USER_TO_SURFACE matrix.
	AMfloat glyphUserToSurfaceScale[2];
	//! Flags to describe the status of the current VG_MATRIX_GLYPH_USER_TO_SURFACE matrix.
	AMuint32 glyphUserToSurfaceFlags;
#endif
	//! Pointer to the current selected matrix.
	AMMatrix33f *selectedMatrix;
	//! Pointer to the inverse of the current selected matrix.
	AMMatrix33f *selectedInverseMatrix;
	//! Pointer to the scale factors of the current selected matrix.
	AMfloat *selectedMatrixScale;
	//! Pointer to the flags of the current selected matrix.
	AMuint32 *selectedMatrixFlags;
	//@}

	//!	\name Curves flattening structures.
	//@{
	//! Temporary array of point used to store (0-based) flattening points of each curve segment.
	AMVect2fDynArray tmpFlatteningPts;
	//! Scalar factor used to control flattening quality.
	AMfloat curvesQuality;
	//! Set of parameters used by curve flattening algorithms.
	AMFlattenParams flattenParams;
	//@}

	//!	\name Stroking structures and derived data.
	//@{
	//! Stroke line thickness, defined as strokeLineWidth / 2.
	AMfloat strokeLineThickness;
	//! Defined as miterLimit * strokeLineThickness.
	AMfloat miterMulThickness;
	//! Defined as square of miterMulThickness.
	AMfloat miterMulThicknessSqr;
#if defined(AM_FIXED_POINT_PIPELINE)
	//! Array of points used to store polygons that realize the stroke.
	AMVect2xDynArray strokeAuxPts;
	//! Temporary array used to build the stroke right-side.
	AMVect2xDynArray strokeAuxPtsDx;
#else
	//! Array of points used to store polygons that realize the stroke.
	AMVect2fDynArray strokeAuxPts;
	//! Temporary array used to build the stroke right-side.
	AMVect2fDynArray strokeAuxPtsDx;
#endif
	//! Number of points for each stroke polygon.
	AMInt32DynArray strokeAuxPtsPerContour;
	//! Size of strokeAuxPts before to close a new stroke polygon.
	AMuint32 strokeAuxPtsOldSize;
	//! Last point on the stroke left-side.
	AMVect2f strokeLeftPoint;
	//! Last point on the stroke right-side.
	AMVect2f strokeRightPoint;
	//! Central point, between strokeLeftPoint and strokeRightPoint.
	AMVect2f strokeMiddlePoint;
	//! AM_TRUE if the last stroke join has been realized using more than one pieces.
	AMbool lastJoinSeparated;
	//! Patched dash pattern (even number of elements and positive values).
	AMFloatDynArray patchedDashPattern;
	//! Sum of all dash pattern values contained inside patchedDashPattern.
	AMfloat dashPatternSum;
	//@}

	//!	\name Auxiliary arrays, used by VGU functions.
	//@{
	//! Array of commands used by VGU functions.
	AMUint8DynArray vguAuxCommands;
	//! Array of 8bit integer coordinates used by VGU functions.
	AMInt8DynArray vguAuxS8Data;
	//! Array of 16bit integer coordinates used by VGU functions.
	AMInt16DynArray vguAuxS16Data;
	//! Array of 32bit integer coordinates used by VGU functions.
	AMInt32DynArray vguAuxS32Data;
	//! Array of 32bit float coordinates used by VGU functions.
	AMFloatDynArray vguAuxF32Data;
	//@}

	//! Pointer to the main rasterizer structure (allocated during context initialization).
	AMRasterizer *rasterizer;
	//! AM_TRUE if a path drawing function has not reahed the rasterization stage, else AM_FALSE;
	AMbool beforePathRasterization;

	//!	\name Constant function tables.
	//@{
	//! Table that contains function pointers to calculate curves length.
	AMPathSegmentLengthFunction lengthFunctions[AM_PATH_SEGMENT_TYPES_COUNT];
	//! Table that contains function pointers to calculate curves length parametrization.
	AMPathSegmentParamFunction paramFunctions[AM_PATH_SEGMENT_TYPES_COUNT];
	//! Table that contains function pointers to calculate curves position.
	AMPathSegmentEvalFunction evalFunctions[AM_PATH_SEGMENT_TYPES_COUNT];
	//! Table that contains function pointers to calculate curves bounding box.
	AMPathSegmentBoxEvalFunction boxEvalFunctions[AM_PATH_SEGMENT_TYPES_COUNT];
	//! Table that contains function pointers to flatten curves.
	AMPathSegmentFlattenFunction flattenFunctions[AM_PATH_SEGMENT_TYPES_COUNT];
	//! Table that contains function pointers to coordinate converters ([dstFormat][srcFormat]).
	AMPathCoordinatesConverterFunction coordinatesConverters[AM_PATH_DATATYPES_COUNT][AM_PATH_DATATYPES_COUNT];

#if !defined(AM_LITE_PROFILE)
	//! Table that contains function pointers to pixel format converters , used by image filters ([dstFormat][colorSpace]).
	AMPixel32ConverterFunction pxlConverters[AM_IMAGE_FORMATS_COUNT][4];
#endif

#if defined(AM_SRE) && !defined(AM_LITE_PROFILE)
	//! Table that contains function pointers to path fillers ([paintType][blendMode][masking]).
	AMScanlineFillerFunction pathFillersFunctions[AM_PAINT_TYPES_COUNT][AM_BLEND_MODES_COUNT][2];
	//! Table that contains function pointers to image fillers ([imageMode][blendMode][affine/projective]).
	AMScanlineFillerFunction imageFillersFunctions[AM_IMAGE_MODES_COUNT][AM_BLEND_MODES_COUNT][2];
#endif
	//@}

	//! Paint to use as default.
	VGHandle defaultPaint;
#if defined(AM_SRE) && defined(VG_MZT_conical_gradient)
	//! Table that contains atan2 function values, used by conical gradients. The table is allocated and generated during context initialization.
	AMuint32 *atan2Table;
#endif
	//! Machine endianess, detected at runtime.
	AMEndianessType endianess;
	//! Machine word size, detected at runtime.
	AMuint32 wordSize;
#if defined(VG_MZT_statistics)
	 AMStatisticsInfo statisticsInfo;
#endif
#if defined(AM_DEBUG_MEMORY) && defined(AM_STANDALONE) && (defined(AM_OS_WIN) || defined(AM_OS_WINCE) || defined(AM_OS_LINUX))
	AMuint32 allocatedMemory;
	FILE *memoryLog;
#endif
	//! Configuration parameters read from the external file (e.g. amanithvg.conf)
	AMContextConfParams confParams;
	//! AM_TRUE if the context was successfully initialized, else AM_FALSE.
	AMbool initialized;
} AMContext;

#if defined RIM_VG_SRC
// Set the current context to a new context.
AMContext *amCtxCurrentSet(AMContext *context);
#endif

// Set image quality on the given context.
void amCtxImageQualitySet(AMContext *context,
						  const VGint quality);
// Set rendering quality on the given context.
void amCtxRenderingQualitySet(AMContext *context,
							  const VGRenderingQuality quality);
// Set stroke line width on the given context.
void amCtxStrokeWidthSet(AMContext *context,
						 const VGfloat width);
// Set stroke miter limit on the given context.
void amCtxStrokeMiterLimitSet(AMContext *context,
							  const VGfloat miterLimit);
// Set stroke dash phase on the given context.
void amCtxStrokeDashPhaseSet(AMContext *context,
							 const VGfloat dashPhase);
// Set stroke dash pattern on the given context (integer values).
AMbool amCtxStrokeDashPatternSeti(AMContext *context,
								  const VGint count,
								  const VGint *values);
// Set stroke dash pattern on the given context (float values).
AMbool amCtxStrokeDashPatternSetf(AMContext *context,
								  const VGint count,
								  const VGfloat *values);
// Set matrix mode on the given context.
void amCtxMatrixModeSet(AMContext *context,
						const VGMatrixMode mode);
// Set scissor rectangles on the given context (integer coordinates).
AMbool amCtxScissorRectsSeti(AMContext *context,
						   const VGint count,
						   const VGint *values);
// Set scissor rectangles on the given context (float coordinates).
AMbool amCtxScissorRectsSetf(AMContext *context,
						   const VGint count,
						   const VGfloat *values);
#if (AM_OPENVG_VERSION >= 110)
// Set color transform flag on the given context.
void amCtxColorTransformSet(AMContext *context,
							const VGboolean colorTransform);
// Set color transform values on the given context (float values).
void amCtxColorTransformValuesSetf(AMContext *context,
								   const VGfloat *colorTransformValues);
// Set color transform values on the given context (integer values).
void amCtxColorTransformValuesSeti(AMContext *context,
								   const VGint *colorTransformValues);
#endif
// Retrieve memory from handles.
void amMemMngRetrieve(AMContext *context,
					  const AMbool maxMemoryRetrieval);
// Decrement the counter of the memory manager.
void amCtxMemMngCountDown(AMContext *context);
// Create a new VGHandle.
VGHandle amCtxHandleNew(AMContext *context,
						AMhandle object);
// Remove a VGHandle.
AMhandle amCtxHandleRemove(AMContext *context,
						   const VGHandle handle);
// Check if an handle is valid for the given context.
AMuint32 amCtxHandleValid(const AMContext *context,
						  const VGHandle handle);
// Increment the reference counter of a given object (path, image, paint).
AMuint32 amCtxHandleRefCounterInc(AMhandle object);
// Decrement the reference counter of a given object (path, image, paint).
AMuint32 amCtxHandleRefCounterDec(AMhandle object,
								  AMContext *context);
#if defined(AM_DEBUG_MEMORY)
void amCtxCheckConsistence(AMContext *context);
#endif

void amCtxConfigParametersLoad(AMContextConfParams *confParams);
// Initialize a given OpenVG context.
AMbool amCtxInit(AMContext *context,
				 AMContext *sharedContext,
				 const AMContextConfParams *confParams);
// Destroy a given OpenVG context.
void amCtxDestroy(AMContext *context);

/*!
	\brief Set an error code into the given context.
	\param context context containing the current error code.
	\param error input error code to set.
*/
AM_INLINE void amCtxErrorSet(AMContext *context,
							 const VGErrorCode error) {
	 if (context->error == VG_NO_ERROR)
		 context->error = error;
}

#endif
