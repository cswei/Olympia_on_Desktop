/*
 * Copyright (C) Research In Motion Limited 2010. All rights reserved.
 */

#include "SurfacePool.h"

#include "EGLDisplayOpenVG.h"
#include "EGLUtils.h"
#include "OlympiaPlatformMisc.h"

using namespace WebCore;

namespace Olympia {
namespace WebKit {

SurfacePool* SurfacePool::globalSurfacePool()
{
    static SurfacePool* s_instance = 0;
    if (!s_instance)
        s_instance = new SurfacePool;
    return s_instance;
}

SurfacePool::SurfacePool()
{
}

SurfacePool::~SurfacePool()
{
}

void SurfacePool::initialize(const WebCore::IntSize& tileSize)
{
    EGLint      numConfigs;
    EGLConfig   config;

    EGLint attribListConfig[] = {
        EGL_RED_SIZE,           8,
        EGL_GREEN_SIZE,         8,
        EGL_BLUE_SIZE,          8,
        EGL_ALPHA_SIZE,         8,
        EGL_ALPHA_MASK_SIZE,    1,
        EGL_SURFACE_TYPE,       EGL_PBUFFER_BIT,
        EGL_RENDERABLE_TYPE,    EGL_OPENVG_BIT,
        EGL_NONE
    };
    eglChooseConfig(EGLDisplayOpenVG::current()->display(), attribListConfig, &config, 1, &numConfigs);
    ASSERT_EGL_NO_ERROR();
    ASSERT(numConfigs == 1);

    m_tileRenderingSurface.set(new SurfaceOpenVG(tileSize, EGLDisplayOpenVG::current()->display(), &config));

    unsigned tileNumber = 0;
    const char* tileLimit = Olympia::Platform::environment("TILE_NUMBER");
    if (tileLimit)
        tileNumber = strtoul(tileLimit, 0, 0);
    // if TILE_NUMBER was not set or is invalid, default to 24
    if (!tileNumber)
        tileNumber = 24;

    for (size_t i = 0; i < tileNumber; ++i) {
        RefPtr<BackingStoreTile> tile = BackingStoreTile::create(tileSize);
        m_tilePool.append(tile);
    }

    m_checkeredTile = BackingStoreTile::createCheckered(tileSize);
}

void SurfacePool::initializeVisibleTileBuffer(const WebCore::IntSize& visibleSize)
{
    if (!m_visibleTileBuffer || m_visibleTileBuffer->size() != visibleSize) {
        m_visibleTileBuffer.clear();
        m_visibleTileBuffer = BackingStoreTile::createCheckered(visibleSize);
    }
}

void SurfacePool::initializeScrollbars(const WebCore::IntSize& horizontalSize, const WebCore::IntSize& verticalSize)
{
    if (!m_horizontalScrollbar || m_horizontalScrollbar->size() != horizontalSize) {
        m_horizontalScrollbar.clear();
        m_horizontalScrollbar = BackingStoreScrollbar::create(horizontalSize);
    }

    if (!m_verticalScrollbar || m_verticalScrollbar->size() != verticalSize) {
        m_verticalScrollbar.clear();
        m_verticalScrollbar = BackingStoreScrollbar::create(verticalSize);
    }
}

}
}
